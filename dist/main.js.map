{"version":3,"file":"main.js","mappings":"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","sources":["webpack://virusochka/./src/utils/math-utils.ts","webpack://virusochka/./src/area-state-manager.ts","webpack://virusochka/./src/models/cell.ts","webpack://virusochka/./src/models/area.ts","webpack://virusochka/./src/area-renderer.ts","webpack://virusochka/./src/game.ts","webpack://virusochka/./src/main.ts"],"sourcesContent":["export class MathUtils {\r\n    public static minMax(value: number, min: number, max: number): number {\r\n        return Math.min(Math.max(value, min), max);\r\n    }\r\n\r\n    public static generateRandomNumber(min: number, max: number) {\r\n        const ceilMin = Math.ceil(min);\r\n        const floorMax = Math.floor(max);\r\n        return Math.floor(Math.random() * (floorMax - ceilMin + 1)) + ceilMin;\r\n    }\r\n}","import { Area } from \"./models/area\";\r\nimport { Cell } from \"./models/cell\";\r\nimport { ICoord } from \"./models/coord\";\r\nimport { MathUtils } from \"./utils/math-utils\";\r\n\r\nexport class AreaStateManager {\r\n    public history = new Array<Area>();\r\n\r\n    private readonly area: Area;\r\n\r\n    private stateCounter = 0;\r\n    private countOfHealthyCells = 0;\r\n    private infectionProbability: number;\r\n\r\n    constructor(area: Area, infectionProbability: number = 0.5) {\r\n        this.area = area;\r\n        this.infectionProbability = infectionProbability;\r\n\r\n        this.saveHistory();\r\n    }\r\n\r\n    public get isAreaUnchangeable(): boolean {\r\n        return this.area.size * this.area.size === this.countOfHealthyCells;\r\n    }\r\n\r\n    public next(): void {\r\n        if (this.stateCounter !== 0 && this.isAreaUnchangeable) {\r\n            return;\r\n        }\r\n\r\n        this.countOfHealthyCells = 0;\r\n\r\n        if (this.stateCounter === 0) {\r\n            const centerCoord = { i: Math.floor(this.area.size / 2), j: Math.floor(this.area.size / 2) };\r\n            const infectResult = this.area.infectCell(centerCoord);\r\n            if (!infectResult) {\r\n                throw new Error(\"Unable to infect first cell\");\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < this.area.size; i++) {\r\n            for (let j = 0; j < this.area.size; j++) {\r\n                const coord = { i: i, j: j };\r\n\r\n                const cell = this.area.getCell(coord);\r\n                if (!cell) {\r\n                    continue;\r\n                }\r\n\r\n                switch (cell.state) {\r\n                    case \"infected\":\r\n                        if (cell.stateLifetime > 0) {\r\n                            this.processInfectedCell(cell, coord);\r\n                        }\r\n                        break;\r\n                    case \"immune\":\r\n                        this.processImmuneCell(cell, coord);\r\n                        break;\r\n                    case \"healthy\":\r\n                        this.countOfHealthyCells++;\r\n                        break;\r\n                }\r\n\r\n                cell.incrementLifeTime();\r\n            }\r\n        }\r\n\r\n        this.stateCounter++;\r\n\r\n        this.saveHistory();\r\n    }\r\n\r\n    private processInfectedCell(cell: Cell, coord: ICoord): void {\r\n        if (cell.stateLifetime > 5) {\r\n            this.area.immunizeCell(coord);\r\n        } else {\r\n            const healthyNeighborCoords = this.area.getHealthyNeighborCoords(coord);\r\n            const random = MathUtils.generateRandomNumber(1, 100);\r\n            if ((healthyNeighborCoords.length > 0) && (random <= this.infectionProbability * 100)) {\r\n                const random = MathUtils.generateRandomNumber(0, healthyNeighborCoords.length - 1);\r\n                this.area.infectCell(healthyNeighborCoords[random]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private processImmuneCell(cell: Cell, coord: ICoord): void {\r\n        if (cell.stateLifetime > 3) {\r\n            this.area.recoverCell(coord);\r\n        }\r\n    }\r\n\r\n    public setInfectionProbability(value: number): void {\r\n        this.infectionProbability = MathUtils.minMax(value, 0, 1);\r\n    }\r\n\r\n    public reset(): void {\r\n        this.area.resetCells();\r\n        this.resetHistory();\r\n        this.stateCounter = 0;\r\n    }\r\n\r\n    private resetHistory(): void {\r\n        this.history = [];\r\n        this.saveHistory();\r\n    }\r\n\r\n    private saveHistory(): void {\r\n        this.history.push(this.area.copy());\r\n    }\r\n}","import { CellStateType } from \"src/typings/cell\";\r\n\r\nexport class Cell {\r\n    private _state: CellStateType = \"healthy\";\r\n    private _stateLifetime: number = 0;\r\n\r\n    constructor (state: CellStateType = \"healthy\", stateLifetime: number = 0) {\r\n        this._state = state;\r\n        this._stateLifetime = stateLifetime;\r\n    }\r\n\r\n    public get state(): CellStateType {\r\n        return this._state;\r\n    }\r\n\r\n    public get stateLifetime(): number {\r\n        return this._stateLifetime;\r\n    }\r\n\r\n    public infect(): boolean {\r\n        if (this._state !== \"healthy\") {\r\n            return false;\r\n        }\r\n\r\n        this._state = \"infected\";\r\n        this._stateLifetime = 0;\r\n        return true;\r\n    }\r\n\r\n    public immunize(): boolean {\r\n        if (this._state !== \"infected\") {\r\n            return false;\r\n        }\r\n\r\n        this._state = \"immune\";\r\n        this._stateLifetime = 0;\r\n        return true;\r\n    }\r\n\r\n    public recover(): boolean {\r\n        if (this._state !== \"immune\") {\r\n            return false;\r\n        }\r\n\r\n        this._state = \"healthy\";\r\n        this._stateLifetime = 0;\r\n        return true;\r\n    }\r\n\r\n    public reset(): void {\r\n        this._state = \"healthy\";\r\n        this._stateLifetime = 0;\r\n    }\r\n\r\n    public incrementLifeTime(): void {\r\n        this._stateLifetime++;\r\n    }\r\n\r\n    public copy(): Cell {\r\n        return new Cell(this._state, this._stateLifetime);\r\n    }\r\n}","import { AreaRenderer } from \"./../area-renderer\";\r\nimport { MathUtils } from \"../utils/math-utils\";\r\nimport { Cell } from \"./cell\";\r\nimport { ICoord } from \"./coord\";\r\n\r\nexport class Area {\r\n    private static readonly MIN_SIZE = 3;\r\n    private static readonly MAX_SIZE = 111;\r\n\r\n    private readonly renderer: AreaRenderer;\r\n\r\n    private _size = 3;\r\n    private _cells = new Array<Array<Cell>>();\r\n\r\n    constructor(renderer: AreaRenderer, size: number, cells?: Array<Array<Cell>>) {\r\n        this.renderer = renderer;\r\n\r\n        this.size = size;\r\n        this.initCells(cells);\r\n    }\r\n\r\n    private initCells(cells?: Array<Array<Cell>>): void {\r\n        this._cells = new Array<Array<Cell>>();\r\n        for (let i = 0; i < this._size; i++) {\r\n            this._cells.push(new Array<Cell>());\r\n            for (let j = 0; j < this._size; j++) {\r\n                const cell = cells && cells[i][j] ? cells[i][j].copy() : new Cell();\r\n                this._cells[i].push(cell);\r\n            }\r\n        }\r\n    }\r\n\r\n    public get size(): number {\r\n        return this._size;\r\n    }\r\n\r\n    public set size(value: number) {\r\n        if (this._size === value) {\r\n            return;\r\n        }\r\n\r\n        value = MathUtils.minMax(value, Area.MIN_SIZE, Area.MAX_SIZE);\r\n        this._size = (value & 1) ? value : value - 1;\r\n        this.initCells();\r\n    }\r\n\r\n    public resetCells(): void {\r\n        this._cells.forEach(row => {\r\n            row.forEach(cell => cell.reset());\r\n        });\r\n        this.render();\r\n    }\r\n\r\n    public infectCell(coord: ICoord): boolean {\r\n        const cell = this.getCell(coord);\r\n        const succeed = cell?.infect() ?? false;\r\n        this.renderer.renderCell(cell, coord);\r\n        return succeed;\r\n    }\r\n\r\n    public immunizeCell(coord: ICoord): boolean {\r\n        const cell = this.getCell(coord);\r\n        const succeed = cell?.immunize() ?? false;\r\n        this.renderer.renderCell(cell, coord);\r\n        return succeed;\r\n    }\r\n\r\n    public recoverCell(coord: ICoord): boolean {\r\n        const cell = this.getCell(coord);\r\n        const succeed = cell?.recover() ?? false;\r\n        this.renderer.renderCell(cell, coord);\r\n        return succeed;\r\n    }\r\n\r\n    public render(): void {\r\n        this.renderer.render(this);\r\n    }\r\n\r\n    public getCell(coord: ICoord): Cell | null {\r\n        const i = MathUtils.minMax(coord.i, 0, this._cells.length);\r\n        const j = MathUtils.minMax(coord.j, 0, this._cells[0].length);\r\n\r\n        try {\r\n            return this._cells[i][j];\r\n        } catch {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public getHealthyNeighborCoords(coord: ICoord): Array<ICoord> {\r\n        const result = new Array<ICoord>();\r\n\r\n        [\r\n            { i: coord.i, j: coord.j - 1 },\r\n            { i: coord.i - 1, j: coord.j - 1 },\r\n            { i: coord.i - 1, j: coord.j },\r\n            { i: coord.i - 1, j: coord.j + 1 },\r\n            { i: coord.i, j: coord.j + 1 },\r\n            { i: coord.i + 1, j: coord.j + 1 },\r\n            { i: coord.i + 1, j: coord.j },\r\n            { i: coord.i + 1, j: coord.j - 1 }\r\n        ].forEach((coord: ICoord) => {\r\n            try {\r\n                if (this._cells[coord.i][coord.j] && this._cells[coord.i][coord.j].state === \"healthy\") {\r\n                    result.push(coord);\r\n                }\r\n            } catch {\r\n                // do nothing\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n\r\n    public copy(): Area {\r\n        return new Area(this.renderer, this._size, this._cells);\r\n    }\r\n}","import { Area } from \"./models/area\";\r\nimport { Cell } from \"./models/cell\";\r\nimport { ICoord } from \"./models/coord\";\r\n\r\nexport class AreaRenderer {\r\n    private readonly BORDER_SIZE = 2;\r\n\r\n    private readonly canvasEl: HTMLCanvasElement;\r\n    private readonly ctx: CanvasRenderingContext2D;\r\n\r\n    private cellSize: number = 100;\r\n\r\n    constructor() {\r\n        this.canvasEl = document.getElementById(\"canvas\") as HTMLCanvasElement;\r\n        this.ctx = this.canvasEl.getContext(\"2d\") as CanvasRenderingContext2D;\r\n\r\n        if (!this.canvasEl || !this.ctx) {\r\n            throw new Error(\"Unable to create AreaRenderer\");\r\n        }\r\n    }\r\n\r\n    public render(area: Area): void {\r\n        this.cellSize = (this.canvasEl.width - this.BORDER_SIZE) / area.size;\r\n\r\n        this.ctx.fillStyle = \"#000\";\r\n        this.ctx.fillRect(0, 0, this.canvasEl.width, this.canvasEl.height);\r\n\r\n        for (let i = 0; i < area.size; i++) {\r\n            for (let j = 0; j < area.size; j++) {\r\n                const coord = { i: i, j: j };\r\n                this.renderCell(area.getCell(coord), coord);\r\n            }\r\n        }\r\n    }\r\n\r\n    public renderCell(cell: Cell | null, coord: ICoord): void {\r\n        if (!cell) {\r\n            return;\r\n        }\r\n\r\n        this.ctx.fillStyle = this.getCellColor(cell);\r\n        this.ctx.fillRect(\r\n            coord.j * this.cellSize + this.BORDER_SIZE,\r\n            coord.i * this.cellSize + this.BORDER_SIZE,\r\n            this.cellSize - this.BORDER_SIZE,\r\n            this.cellSize - this.BORDER_SIZE\r\n        );\r\n    }\r\n\r\n    private getCellColor(cell: Cell | null): string {\r\n        if (!cell) {\r\n            return \"#ffffff\";\r\n        }\r\n\r\n        switch (cell.state) {\r\n            case \"infected\":\r\n                return \"#c71010\";\r\n            case \"immune\":\r\n                return \"#c7c110\";\r\n            case \"healthy\":\r\n                return \"#00992b\";\r\n            default:\r\n                return \"#ffffff\";\r\n        }\r\n    }\r\n}","import { AreaStateManager } from \"./area-state-manager\";\r\nimport { Area } from \"./models/area\";\r\nimport { AreaRenderer } from \"./area-renderer\";\r\n\r\nexport class Game {\r\n    public timeoutInSec = 0.3;\r\n\r\n    private readonly areaRenderer = new AreaRenderer();\r\n    private readonly area = new Area(this.areaRenderer, 5);\r\n    private readonly areaStateManager = new AreaStateManager(this.area);\r\n\r\n    public gameTickCounter = 0;\r\n\r\n    private running = false;\r\n    private dateStart = 0;\r\n    private animationRequestId = 0;\r\n\r\n    public init(): void {\r\n        this.area.render();\r\n    }\r\n\r\n    public start(): void {\r\n        if (this.running) {\r\n            return;\r\n        }\r\n\r\n        this.area.render();\r\n        this.startGameAnimation();\r\n\r\n        this.running = true;\r\n    }\r\n\r\n    private startGameAnimation(): void {\r\n        this.animationRequestId = window.requestAnimationFrame(this.gameTick);\r\n    }\r\n\r\n    private gameTick = (now: number) => {\r\n        if (!this.dateStart || now - this.dateStart >= this.timeoutInSec * 1000) {\r\n            this.dateStart = now;\r\n            this.areaStateManager.next();\r\n            if (this.areaStateManager.isAreaUnchangeable) {\r\n                this.stop();\r\n                this.reset();\r\n            }\r\n\r\n            this.gameTickCounter++;\r\n        }\r\n\r\n        if (this.running) {\r\n            window.requestAnimationFrame(this.gameTick);\r\n        }\r\n    };\r\n\r\n    public stop(): void {\r\n        this.stopGameAnimation();\r\n\r\n        this.running = false;\r\n    }\r\n\r\n    private stopGameAnimation(): void {\r\n        window.cancelAnimationFrame(this.animationRequestId);\r\n        this.animationRequestId = 0;\r\n    }\r\n\r\n    public reset(): void {\r\n        this.areaStateManager.reset();\r\n        this.gameTickCounter = 0;\r\n        this.stop();\r\n    }\r\n\r\n    public setSize(size: number): void {\r\n        this.area.size = size;\r\n        this.area.render();\r\n    }\r\n\r\n    public setInfectionProbability(value: number): void {\r\n        this.areaStateManager.setInfectionProbability(value);\r\n    }\r\n\r\n    public getSize(): number {\r\n        return this.area.size;\r\n    }\r\n}","import { Game } from \"./game\";\r\n\r\n(w => {\r\n    const game = new Game();\r\n    w[\"game\"] = game;\r\n    game.init();\r\n\r\n    const timeoutInput = document.getElementById(\"timeout\") as HTMLInputElement;\r\n    timeoutInput.addEventListener(\"input\", () => {\r\n        window[\"game\"].timeoutInSec = Number.parseFloat(timeoutInput.value);\r\n    });\r\n\r\n    const areaSizeInput = document.getElementById(\"area-size\") as HTMLInputElement;\r\n    areaSizeInput.addEventListener(\"input\", () => {\r\n        window[\"game\"].setSize(Number.parseInt(areaSizeInput.value));\r\n    });\r\n\r\n    const infectionProbability = document.getElementById(\"infection-probability\") as HTMLInputElement;\r\n    infectionProbability.addEventListener(\"input\", () => {\r\n        window[\"game\"].setInfectionProbability(Number.parseFloat(infectionProbability.value));\r\n    });\r\n\r\n    game.timeoutInSec = Number.parseFloat(timeoutInput.value);\r\n    game.setSize(Number.parseInt(areaSizeInput.value));\r\n    game.setInfectionProbability(Number.parseFloat(infectionProbability.value));\r\n})(window);\r\n"],"names":["MathUtils","static","value","min","max","Math","ceilMin","ceil","floorMax","floor","random","AreaStateManager","constructor","area","infectionProbability","history","Array","stateCounter","countOfHealthyCells","this","saveHistory","isAreaUnchangeable","size","next","centerCoord","i","j","infectCell","Error","coord","cell","getCell","state","stateLifetime","processInfectedCell","processImmuneCell","incrementLifeTime","immunizeCell","healthyNeighborCoords","getHealthyNeighborCoords","generateRandomNumber","length","recoverCell","setInfectionProbability","minMax","reset","resetCells","resetHistory","push","copy","Cell","_state","_stateLifetime","infect","immunize","recover","Area","renderer","cells","_size","_cells","initCells","MIN_SIZE","MAX_SIZE","forEach","row","render","succeed","renderCell","result","AreaRenderer","BORDER_SIZE","cellSize","canvasEl","document","getElementById","ctx","getContext","width","fillStyle","fillRect","height","getCellColor","Game","timeoutInSec","areaRenderer","areaStateManager","gameTickCounter","running","dateStart","animationRequestId","gameTick","now","stop","window","requestAnimationFrame","init","start","startGameAnimation","stopGameAnimation","cancelAnimationFrame","setSize","getSize","w","game","timeoutInput","addEventListener","Number","parseFloat","areaSizeInput","parseInt"],"sourceRoot":""}
